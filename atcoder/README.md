## ABC memo
abc148_c: lcm = a*b / gcd(a, b) \
abc147_c: 状態は二値の組なのでbit全探索, 状態を決め打ちしたら矛盾の検出は容易\
abc145_c: `next_permutation( begin(v), end(v) )` は、辞書順の上でひとつずつ最後まで並び替える \
abc141_d: 積で割って小数点切り捨てるのと、ひとつずつ割りながら切り捨てるのは同じ \
abc140_e: 区間端のインデックスを集合で管理する. 大きい順に見ていく. 境界条件を楽に管理する.  \
abc138_d: C++でも `max(N*Q)=40000000000` (10^10, 百億) 程度の規模ループが走ると 2 秒では終わらない. 木の場合, "あるノードの親" を保持するデータ構造の方が筋が良いことがある \
abc137_c: ハッシュテーブルは `O(1)` で任意要素にアクセスできる \
abc137_d: **優先度度付きキュー**は push に `O(logN)` かかるが `O(1)` で最大要素にアクセスできる. 本問のように徐々に広がる範囲の中から最大値を次々求めるときなどに有用 \
abc135_c: **`10^9` は `int` の外** \
abc135_d: 剰余は各桁でバラせば独立なので, 13 x len(S) のdpを用いて, i桁目までのパターン数からi+1桁目までのパターン数を計算していける \
abc133_c: `(a*b) % p = ((a % p)*(b % p)) % p`であり, 剰余の世界は p 未満の数しかない\
abc133_d: WA 漸化式や総和を考えるとアルゴリズミックに解くやり方が見える？ `+=`の際には変数の初期化忘れに注意. \
abc131_c: `gcd(a,b) * lcm(a,b) = a*b` 境界条件 要注意 \
abc129_c: i番目の状態は有限の事前状態から求まるのでdp \
abc125_c: gcd はどの順番で計算してもよい `gcd(X,Y,Z) = gcd(gcd(X,Y),Z) = gcd(X, gcd(Y,Z))` ため、左からのgcdと右からのgcdを計算しておけば、i番目を除外したgcdは log(min(a,b)) で求まる \
abc124_c: stringに添字つけて取り出した文字は char. うっかり char で書かれた数字と int を比較しないように \
abc122_c: 1文字目からi番目までに出現する"AC"の数でdpをして、区間端で引く 