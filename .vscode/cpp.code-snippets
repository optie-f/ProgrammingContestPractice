{
  // Place your ProgrammingContestPractice workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "cin": {
    "prefix": "cin1",
    "body": ["cin >> $1;"],
    "description": "cin1"
  },
  "cin2": {
    "prefix": "cin2",
    "body": ["cin >> $1 >> $2;"],
    "description": "cin2"
  },
  "cin3": {
    "prefix": "cin3",
    "body": ["cin >> $1 >> $2 >> $3;"],
    "description": "cin3"
  },
  "cin_string": {
    "prefix": "cins",
    "body": ["string $1; cin >> $1;"],
    "description": "sring型の受取"
  },
  "cin2_string": {
    "prefix": "cins2",
    "body": ["string $1, $2; cin >> $1 >> $2;"],
    "description": "string型の受取2"
  },
  "cin_int": {
    "prefix": "cint",
    "body": ["int $1; cin >> $1;"],
    "description": "int型の受取"
  },
  "cin2_int": {
    "prefix": "cint2",
    "body": ["int $1, $2; cin >> $1 >> $2;"],
    "description": "int型の受取2"
  },
  "cin3_int": {
    "prefix": "cint3",
    "body": ["int $1, $2, $3; cin >> $1 >> $2 >> $3;"],
    "description": "int型の受取3"
  },
  "cin_ll": {
    "prefix": "cinll",
    "body": ["LL $1; cin >> $1;"],
    "description": "ll型の受取"
  },
  "cin2_ll": {
    "prefix": "cin2ll",
    "body": ["LL $1, $2; cin >> $1 >> $2;"],
    "description": "ll型の受取2"
  },
  "cin3_ll": {
    "prefix": "cin3ll",
    "body": ["LL $1, $2, $3; cin >> $1 >> $2 >> $3;"],
    "description": "ll型の受取3"
  },
  "civector_int": {
    "prefix": "cvi",
    "body": ["vector<int> $1($2);", "REP0(i, $2)", "{", "  cin >> $1[i];", "}"],
    "description": "vector<int>の受取"
  },
  "cin_vector_ll": {
    "prefix": "cvl",
    "body": ["vector<LL> $1($2);", "REP0(i, $2)", "{", "  cin >> $1[i];", "}"],
    "description": "vector<ll>の受取"
  },
  "cout": {
    "prefix": "cout",
    "body": ["std::cout << $0;"],
    "description": "出力"
  },
  "cout_endl": {
    "prefix": "coutend",
    "body": ["std::cout << $0 << endl;"],
    "description": "出力"
  },
  "sort": {
    "prefix": "sort",
    "body": ["sort($1.begin(), $1.end());"],
    "description": "sort"
  },
  "sortcond": {
    "prefix": "sortby",
    "body": ["sort($1.begin(), $1.end(), []($2 a, $2 b){return a$3 < b; });"],
    "description": "sort"
  },
  "reverse": {
    "prefix": "rev",
    "body": ["reverse($1.begin(), $1.end());"],
    "description": "reverse"
  },
  "fill": {
    "prefix": "fill",
    "body": ["fill($1.begin(), $1.end());"],
    "description": "fill"
  },
  "find": {
    "prefix": "find",
    "body": ["$1.find($2) != $1.end()"],
    "description": "find"
  },
  "REP0": {
    "prefix": "REP0",
    "body": ["REP0($1, $2)", "{", "    $0", "}"],
    "description": "REP0"
  },
  "RREP0": {
    "prefix": "RREP0",
    "body": ["RREP0($1, $2)", "{", "    $0", "}"],
    "description": "RREP0"
  },

  "REP1": {
    "prefix": "REP1",
    "body": ["REP1($1, $2)", "{", "    $0", "}"],
    "description": "REP1"
  },
  "FORab": {
    "prefix": "FORab",
    "body": ["FOR($1, $2, $3)", "{", "    $0", "}"],
    "description": "FOR(i, a, b)"
  },
  "for": {
    "prefix": "for",
    "body": ["for ($1 $2 = $3; $2 $4; $2 $5)", "{", "    $0", "}"],
    "description": "FOR"
  },
  "forauto": {
    "prefix": "fora",
    "body": ["for (auto $1 : $2)", "{", "    $0", "}"],
    "description": "for auto"
  },
  "vector": {
    "prefix": "vec",
    "body": ["vector<$1> $2"],
    "description": "vector"
  },
  "pair": {
    "prefix": "pa",
    "body": ["pair<$1, $2> $3"],
    "description": "pair"
  },
  "map": {
    "prefix": "map",
    "body": ["map<$1, $2> $3"],
    "description": "map"
  },
  "stack": {
    "prefix": "sta",
    "body": ["stack<$1> $2"],
    "description": "stack"
  },
  "queue": {
    "prefix": "qu",
    "body": ["queue<$1> $2"],
    "description": "queue"
  },
  "min3": {
    "prefix": "min3",
    "body": ["min(min($1, $2), $3)"],
    "description": "min of 3"
  },
  "max3": {
    "prefix": "max3",
    "body": ["max(max($1, $2), $3)"],
    "description": "max of 3"
  },
  "mid3": {
    "prefix": "mid3",
    "body": ["max(min($1,$2), min(max($1,$2),$3))"],
    "description": "median of 3"
  },
  "dxdy4": {
    "prefix": "dxdy4",
    "body": ["int dx[4] = {-1, 0, 1, 0};", "int dy[4] = {0, 1, 0, -1};"],
    "description": "dxdy4"
  },
  "dxdy8": {
    "prefix": "dxdy8",
    "body": [
      "int dx[4] = {-1, -1, 0, 1, 1, 1, 0, -1};",
      "int dy[4] = {0, 1, 1, 1, 0, -1, -1, -1};"
    ],
    "description": "dxdy4"
  },
  "pos": {
    "prefix": "pos",
    "body": ["struct pos", "{", "    int x;", "    int y;", "};"],
    "description": "struct pos"
  },
  "mod1e9": {
    "prefix": "mod",
    "body": "const LL  mod = LL(1e9) + 7;",
    "description": "const LL mod = 1e9 + 7"
  },
  "WarshallFloyd": {
    "prefix": "wa",
    "body": [
      "REP0 (k, $1) REP0 (i, $1) REP0 (j, $1) $2[i][j] = min($2[i][j], $2[i][k]+[k][j]);"
    ],
    "description": "WarshallFloyd O(|V|^3)"
  },
  "gcd": {
    "prefix": "gcd",
    "body": ["LL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; };"],
    "description": "最大公約数 O(log max(a, b))"
  },
  "lcm": {
    "prefix": "lcm",
    "body": ["LL lcm(LL a, LL b) { return a * (b / gcd(a, b)); };"],
    "description": "最小公倍数"
  },
  "popcnt": {
    "prefix": "popcnt",
    "body": ["__builtin_popcount($1)"],
    "description": "1であるようなbitの数"
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "template <int MOD>",
      "struct intmod",
      "{ // modified from http://drken1215.hatenablog.com/entry/2020/02/09/225000",
      "    long long val;",
      "    constexpr intmod(long long v = 0) noexcept : val(v % MOD)",
      "    {",
      "        if (val < 0)",
      "            val += MOD;",
      "    }",
      "    constexpr int getmod() { return MOD; }",
      "    constexpr intmod operator-() const noexcept",
      "    {",
      "        return val ? MOD - val : 0;",
      "    }",
      "    constexpr intmod operator+(const intmod &r) const noexcept { return intmod(*this) += r; }",
      "    constexpr intmod operator-(const intmod &r) const noexcept { return intmod(*this) -= r; }",
      "    constexpr intmod operator*(const intmod &r) const noexcept { return intmod(*this) *= r; }",
      "    constexpr intmod operator/(const intmod &r) const noexcept { return intmod(*this) /= r; }",
      "    constexpr intmod &operator+=(const intmod &r) noexcept",
      "    {",
      "        val += r.val;",
      "        if (val >= MOD)",
      "            val -= MOD;",
      "        return *this;",
      "    }",
      "    constexpr intmod &operator-=(const intmod &r) noexcept",
      "    {",
      "        val -= r.val;",
      "        if (val < 0)",
      "            val += MOD;",
      "        return *this;",
      "    }",
      "    constexpr intmod &operator*=(const intmod &r) noexcept",
      "    {",
      "        val = val * r.val % MOD;",
      "        return *this;",
      "    }",
      "    constexpr intmod &operator/=(const intmod &r) noexcept",
      "    {",
      "        long long a = r.val, b = MOD, u = 1, v = 0;",
      "        while (b)",
      "        {",
      "            long long t = a / b;",
      "            a -= t * b;",
      "            swap(a, b);",
      "            u -= t * v;",
      "            swap(u, v);",
      "        }",
      "        val = val * u % MOD;",
      "        if (val < 0)",
      "            val += MOD;",
      "        return *this;",
      "    }",
      "    constexpr bool operator==(const intmod &r) const noexcept",
      "    {",
      "        return this->val == r.val;",
      "    }",
      "    constexpr bool operator!=(const intmod &r) const noexcept",
      "    {",
      "        return this->val != r.val;",
      "    }",
      "    friend constexpr ostream &operator<<(ostream &os, const intmod<MOD> &x) noexcept",
      "    {",
      "        return os << x.val;",
      "    }",
      "    friend constexpr intmod<MOD> modpow(const intmod<MOD> &a, long long n) noexcept",
      "    {",
      "        if (n == 0)",
      "            return 1;",
      "        auto t = modpow(a, n / 2);",
      "        t = t * t;",
      "        if (n & 1)",
      "            t = t * a;",
      "        return t;",
      "    }",
      "};",
      "const int mod = int(1e9) + 7;",
      "typedef intmod<mod> mint;"
    ],
    "description": "mod int"
  },
  "UnionFind": {
    "prefix": "unionfind",
    "body": [
      "// 頂点をインデックスで管理する",
      "struct UnionFind",
      "{",
      "    std::vector<int> rank;  // 木の高さ",
      "    std::vector<int> p;     // 頂点 i の親, root であれば i == p[i]",
      "    std::vector<int> cnt;   // 頂点 i を root とする連結成分の要素数",
      "    int connected;          // 異なる連結成分の個数",
      "",
      "    UnionFind(){};",
      "    UnionFind(int size)",
      "    {",
      "        init(size);",
      "    }",
      "",
      "    void init(int size)",
      "    {",
      "        connected = size;",
      "        rank.resize(size, 0);",
      "        p.resize(size, 0);",
      "        cnt.resize(size, 0);",
      "        for (int i = 0; i < size; i++) makeSet(i);",
      "    }",
      "",
      "    void makeSet(int x)",
      "    {  // 頂点 x からなる単一連結成分",
      "        p[x] = x;",
      "        rank[x] = 0;",
      "        cnt[x] = 1;",
      "    }",
      "",
      "    bool same(int x, int y)",
      "    {  // 頂点 x,y の属する連結成分の root が同一ならば, x, y は同じ連結成分",
      "        return findSet(x) == findSet(y);",
      "    }",
      "",
      "    void unite(int x, int y)",
      "    {  // 頂点 x, y が異なる連結成分のとき、これらを併合",
      "        if (same(x, y))",
      "            return;",
      "        link(findSet(x), findSet(y));",
      "    }",
      "",
      "    void link(int x, int y)",
      "    {  // 頂点 x, y が異なる連結成分との仮定のもと、併合",
      "        connected--;",
      "        if (rank[x] > rank[y])",
      "        {",
      "            p[y] = x;",
      "            cnt[x] += cnt[y];",
      "        }",
      "        else",
      "        {",
      "            p[x] = y;",
      "            cnt[y] += cnt[x];",
      "            rank[y] += (rank[x] == rank[y]);",
      "        }",
      "    }",
      "",
      "    int findSet(int x)",
      "    {  // 頂点 x が属する連結成分の root",
      "        if (x != p[x])",
      "        {",
      "            p[x] = findSet(p[x]);",
      "        }",
      "        return p[x];",
      "    }",
      "",
      "    int setSize(int x)",
      "    {  // 頂点 x が属する連結成分の頂点数",
      "        return cnt[findSet(x)];",
      "    }",
      "};"
    ],
    "description": "union find"
  },
  "segtree": {
    "prefix": "seg",
    "body": [
      "template <typename Monoid> struct SegTree",
      "{",
      "    typedef function<Monoid(Monoid, Monoid)> F;",
      "    std::vector<Monoid> data;  // 0-indexed 配列に完全二分木",
      "    const Monoid e;            // 単位元",
      "    const F f;",
      "    int N = 1;",
      "",
      "    SegTree(int size, const F f, const Monoid &e) : f(f), e(e)",
      "    {",
      "        while (N < size) N <<= 1;",
      "        data.resize(2 * N - 1, e);  // 要素数 n => ノード数 2*n - 1",
      "    }",
      "",
      "    void update(int i, Monoid x)",
      "    {",
      "        i += N - 1;  // 要素 i の木中ノード番号",
      "        data[i] = x;",
      "        while (i > 0)",
      "        {",
      "            i       = (i - 1) / 2;  // 親ノード番号",
      "            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);",
      "        }",
      "    }",
      "",
      "    Monoid query(int q_l, int q_r)",
      "    {  // [q_l, q_r) に対するクエリの処理",
      "        return _query(q_l, q_r, 0, 0, N);",
      "    }",
      "",
      "   private:",
      "    Monoid _query(int q_l, int q_r, int k, int k_l, int k_r)",
      "    {  // ノード k : 区間は [k_l, k_r) について",
      "        if (k_r <= q_l || q_r <= k_l)",
      "            return e;  // 交差しない",
      "        if (q_l <= k_l && k_r <= q_r)",
      "            return data[k];  // 完全に含む→受け止める",
      "        else",
      "        {",
      "            Monoid vl = _query(q_l, q_r, k * 2 + 1, k_l, (k_l + k_r) / 2);",
      "            Monoid vr = _query(q_l, q_r, k * 2 + 2, (k_l + k_r) / 2, k_r);",
      "            return f(vl, vr);",
      "        }",
      "    }",
      "};"
    ],
    "description": "ordinary segment tree. Monoid は演算が定義される集合(intやbitsetなど)"
  },
  "combination": {
    "prefix": "comb",
    "body": [
      "template <int MOD> struct intmod",
      "{  // modified from http://drken1215.hatenablog.com/entry/2020/02/09/225000",
      "    long long val;",
      "    constexpr intmod(long long v = 0) noexcept : val(v % MOD)",
      "    {",
      "        if (val < 0)",
      "            val += MOD;",
      "    }",
      "    constexpr int getmod()",
      "    {",
      "        return MOD;",
      "    }",
      "    constexpr intmod operator-() const noexcept",
      "    {",
      "        return val ? MOD - val : 0;",
      "    }",
      "    constexpr intmod operator+(const intmod &r) const noexcept",
      "    {",
      "        return intmod(*this) += r;",
      "    }",
      "    constexpr intmod operator-(const intmod &r) const noexcept",
      "    {",
      "        return intmod(*this) -= r;",
      "    }",
      "    constexpr intmod operator*(const intmod &r) const noexcept",
      "    {",
      "        return intmod(*this) *= r;",
      "    }",
      "    constexpr intmod operator/(const intmod &r) const noexcept",
      "    {",
      "        return intmod(*this) /= r;",
      "    }",
      "    constexpr intmod &operator+=(const intmod &r) noexcept",
      "    {",
      "        val += r.val;",
      "        if (val >= MOD)",
      "            val -= MOD;",
      "        return *this;",
      "    }",
      "    constexpr intmod &operator-=(const intmod &r) noexcept",
      "    {",
      "        val -= r.val;",
      "        if (val < 0)",
      "            val += MOD;",
      "        return *this;",
      "    }",
      "    constexpr intmod &operator*=(const intmod &r) noexcept",
      "    {",
      "        val = val * r.val % MOD;",
      "        return *this;",
      "    }",
      "    constexpr intmod &operator/=(const intmod &r) noexcept",
      "    {",
      "        long long a = r.val, b = MOD, u = 1, v = 0;",
      "        while (b)",
      "        {",
      "            long long t = a / b;",
      "            a -= t * b;",
      "            swap(a, b);",
      "            u -= t * v;",
      "            swap(u, v);",
      "        }",
      "        val = val * u % MOD;",
      "        if (val < 0)",
      "            val += MOD;",
      "        return *this;",
      "    }",
      "    constexpr bool operator==(const intmod &r) const noexcept",
      "    {",
      "        return this->val == r.val;",
      "    }",
      "    constexpr bool operator!=(const intmod &r) const noexcept",
      "    {",
      "        return this->val != r.val;",
      "    }",
      "    friend constexpr ostream &operator<<(ostream &os, const intmod<MOD> &x) noexcept",
      "    {",
      "        return os << x.val;",
      "    }",
      "    friend constexpr intmod<MOD> modpow(const intmod<MOD> &a, long long n) noexcept",
      "    {",
      "        if (n == 0)",
      "            return 1;",
      "        auto t = modpow(a, n / 2);",
      "        t      = t * t;",
      "        if (n & 1)",
      "            t = t * a;",
      "        return t;",
      "    }",
      "};",
      "",
      "template <class T> struct BiCoef",
      "{  // modified from http://drken1215.hatenablog.com/entry/2020/02/09/225000",
      "    vector<T> fact_, inv_, finv_;",
      "    constexpr BiCoef()",
      "    {",
      "    }",
      "    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1)",
      "    {",
      "        init(n);",
      "    }",
      "    constexpr void init(int n) noexcept",
      "    {",
      "        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);",
      "        int MOD = fact_[0].getmod();",
      "        for (int i = 2; i < n; i++)",
      "        {",
      "            fact_[i] = fact_[i - 1] * i;",
      "            inv_[i]  = -inv_[MOD % i] * (MOD / i);",
      "            finv_[i] = finv_[i - 1] * inv_[i];",
      "        }",
      "    }",
      "    constexpr T com(int n, int k) const noexcept",
      "    {",
      "        if (n < k || n < 0 || k < 0)",
      "            return 0;",
      "        return fact_[n] * finv_[k] * finv_[n - k];",
      "    }",
      "    constexpr T H(int n, int k) const noexcept",
      "    {",
      "        return com(n + k - 1, k);",
      "    }",
      "    constexpr T fact(int n) const noexcept",
      "    {",
      "        if (n < 0)",
      "            return 0;",
      "        return fact_[n];",
      "    }",
      "    constexpr T inv(int n) const noexcept",
      "    {",
      "        if (n < 0)",
      "            return 0;",
      "        return inv_[n];",
      "    }",
      "    constexpr T finv(int n) const noexcept",
      "    {",
      "        if (n < 0)",
      "            return 0;",
      "        return finv_[n];",
      "    }",
      "};",
      "",
      "const int mod = int(1e9) + 7;",
      "typedef intmod<mod> mint;",
      "typedef BiCoef<mint> BC;",
      "BC bc;"
    ],
    "description": "modint-based combination. bc.init(N) してから bc.com(a,b)"
  },
  "multi_precision": {
    "prefix": "mp",
    "body": [
      "#include <boost/multiprecision/cpp_dec_float.hpp>",
      "namespace mp = boost::multiprecision;"
    ],
    "description": "多倍長整数"
  },
  "PQ dijkstra": {
    "prefix": "dijkstraPQ",
    "body": [
      "    // pair<mincost, 頂点>, typedef pair P, d[i(≠s)]=INF",
      "    priority_queue<P, vector<P>, greater<P>> PQ;",
      "    PQ.push(P(0, s));",
      "    while (PQ.size())",
      "    {",
      "        P p = PQ.top();",
      "        PQ.pop();",
      "        int v = p.second;",
      "        if (d[v] < p.first)",
      "            continue;",
      "        for (auto e : adj[v])",
      "        {",
      "            if (d[e.to] > d[v] + e.cost)",
      "            {",
      "                d[e.to] = d[v] + e.cost;",
      "                PQ.push(pii(d[e.to], e.to));",
      "            }",
      "        }",
      "    }"
    ],
    "description": "dijkstra with priority queue O(ElogV)"
  }
}
